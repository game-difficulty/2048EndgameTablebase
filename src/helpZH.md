
# 用户手册

**作者**：game_difficulty  
**版本**：9.0  
**日期**：2026.1.19  

---

# 1、概述

这是一款功能完善的 2048 游戏训练软件，提供残局计算、残局训练、对局分析、AI 辅助、改版小游戏等丰富功能。

## 1.1 核心亮点
- **计算极速**：采用高度优化的算法和高级剪枝技术实现领先的计算速度，大型定式计算加速可达 10 倍以上。
- **存储高效**：提供多种剪枝和数据压缩技术，大幅减少定式文件的磁盘占用。
- **最强的 AI**：内置最强的 2048 游戏 AI，65536 成功率达 8.4%（±1.6%），32768 成功率达 86.1%（±2.0%），性能远超其他 AI。
- **功能完善**：提供实时反馈、错题本、回放分析等完整的训练与分析工具，帮助用户深入学习游戏策略。

## 1.2 主要功能模块
- **Game**：标准 2048 游戏，内置最强 AI 辅助。
- **Practice**：查看定式，学习最优走法，支持录制和回放。
- **Test**：测试掌握程度，自动记录错题，支持回放分析和 Verse 回放导入。
- **MiniGame**：多种改版小游戏，提供更多挑战。
- **Settings**：全局设置、定式计算、高级算法配置。
- **Help**：帮助文档。

## 1.3 目标用户
- **专业玩家**：需要强大工具研究游戏技巧和策略的玩家。
- **AI 开发者**：希望利用游戏数据训练和优化 AI 的开发者。
- **业余爱好者**：深入学习 2048 残局和定式的玩家。
- **普通玩家**：希望体验改版小游戏或借助 AI 提高分数的玩家。

---

# 2、安装与启动

## 2.1 系统要求
- **操作系统**：Windows 7 及以上版本。
- **内存**：
  - 基础使用：至少 8GB
  - 计算大型定式：建议 32GB 以上，需要时可配置大量虚拟内存
- **磁盘空间**：
  - 基础使用：10GB 以上剩余空间
  - 计算大型定式：根据定式类型，可能需要 1TB 以上剩余空间（建议 SSD）
- **CPU**：
  - 任何 64 位 CPU 均可使用
  - 支持 AVX-512 指令集的 CPU 可获得更好性能
  - 支持多核并行处理
- **GPU**：不依赖 GPU，纯 CPU 运算。

## 2.2 安装步骤
- **解压**：下载并解压软件包。
- **运行**：在解压文件夹中找到 `main.exe`，双击即可启动。
- **首次启动**：软件进行 JIT 编译和初始化，约需 2-10 秒，请耐心等待。

## 2.3 启动说明
- **初始化时间**：首次使用各功能需进行 JIT 编译和资源加载，属于正常现象。
- **错误排查**：出现异常时，请查看 `logger.txt` 文件中的错误信息。

---

# 3、核心概念

## 3.1 残局概念

游戏进行到某一局面时，特定格子已排列好若干大数字，玩家需利用剩余的格子拼凑出目标数字。**残局是从特定局面开始到合成目标数字的整个过程。**

### 示例理解
- **10格16k残局**：局面有大数 8k、4k、2k、1k、512、256（6个），剩余10个空格拼凑新256，最终合并成16k
- **12格32k残局**：局面有 16k、8k、4k、2k（4个），剩余12个空格拼凑2048，最终合并成32k

## 3.2 残局难度分类

残局分类仅与**剩余空间形状**和**目标数字**相关，与现有大数的具体数值和排列顺序无关。若现有大数占用格子数量和位置相同、目标数字一致，则**两个残局在算法层面难度和策略完全相同**，作为同一残局处理。

### 思考题
**问题**：9格65k残局的目标数字是什么？

**提示**：逆向思考——若最终要达成65k（65536），当前已有的大数应该是哪些？

## 3.3 定式概念

**定式是附加了限制条件的残局。**

在实际游戏中，为了可靠达成目标并维持游戏阵型，通常需要：
- 保持大数在相对固定的位置
- 在指定位置合成目标数字

这些限制条件统称为**定式约束**。

### 定式类型对比

| 类型 | 约束强度 | 认知难度（人类） | 理论成功率 | 特点与应用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **常规定式** | **中~高**：锁定大数位置（如蛇形） | **低**：规律明显，易于总结运阵技巧 | **中**：若出现连续极端状况，由于阵型受限，救场能力较弱 | **实战主流**。通过牺牲部分格子的灵活性换取高确定性。 |
| **自由定式 (Free)** | **极低**：大数可按需全盘移动 | **极高**：分支极其复杂，人类计算深度通常无法覆盖 | **最高**：拥有最大的容错空间，能处理最极端的局面组合 | **理论最优解**。用于 AI 跑分、研究极限情况、处理乱阵后的大数归位、学习转阵技巧。 |
| **变体定式 (Variants)** | **极低**：本质是不同棋盘上的自由定式 | **中~低**：状态空间小，逻辑推导深度有限 | **高** | **高精度训练**。由于状态数少，人类可以达到极高的吻合度，常用于针对性练习。 |

### 自由定式示例
- `free9-128`：9个空闲格子，用于在任意位置拼凑128，16k残局
- `free10-512`：10个空闲格子，用于在任意位置拼凑512，32k残局

### 位置定式示例
- `L3-512`：将 6 个大数锁定在边角 2x3 区域，目标512，32k残局
- `442-256`：6个大数下的层叠阵型（蛇形），目标256，16k残局

## 3.4 定式参数详解

| 参数 | 名称 | 说明 | 示例 |
|------|------|------|------|
| **pattern** | 定式名称 | 描述1、定式的约束 2、剩余空间的数量和位置 | `L3`、`442`、`free9` |
| **target** | 目标数字 | 需利用剩余空间合成的数字 | `256`、`512`、`2048` |

### 如何理解定式名称

- **纯数字定式**（如 `442`、`4441`、`4432`）：每行的空位数量
  - `442` = 第一行4格、第二行4格、第三行2格，共10个空位
  - `4431` = 第一行4格、第二行4格、第三行3格、第四行1格，共12个空位
  
- **字母定式**（如 `L3`、`t`、`LL`）：空位排布形状
  - `L3` = 最外层L型 + 3个额外空位，同`4411`
  - `t` = 10个空位以T形排布，同`2422`
  - `LL` = 外层L型 + 内层L型，同`4422`
  
- **free定式**（如 `free9`）：完全自由
  - `free9` = 7个完全自由的大数和9个空位

- **后缀标记**
  - `f (Free)`：自由大数标记。表示在定式锁定的基础大数之外，存在可随操作自由移动的大数。示例：`4432f` 指除 4432 锁定的 3 个大数外，另有 1 个可自由移动的大数（总计 4 个）。`4442ff` 表示存在 2 个可自由移动的大数（总计 4 个）。
  - `t (Transport)`：列内回传标记。允许部分大数在所属列内上下位移。通常用于优化最终合并或紧急救场。`t`定式中，1x2 部分的大数允许上下移动。

### 成功率含义

定式计算得到的**成功率**，表示从该定式当前局面出发、不进行撤销操作、按最优策略行动、最终成功合成目标数字的概率。


---

# 4、功能概览

软件主菜单（**MainMenu**）包含多个功能界面，每个界面有不同的功能模块。通过主界面按钮可快速访问这些模块。以下是各功能界面的简要介绍：

## 4.1 Settings（设置界面）

设置界面分为两部分：**定式计算**和**全局设置**。

### 4.2.1 定式计算部分

**核心参数**：
- **定式名称**：从二级菜单中选择目标定式（如 `L3`、`442`、`free9` 等）
- **目标数字**：选择合成的目标数字（128、256、512、1024、2048...）
- **保存路径**：指定定式数据的保存位置，建议使用本地 SSD 以提高 I/O 速度

**计算选项**：
- **压缩临时文件**：计算期间降低磁盘占用，但增加计算时长
- **压缩**（推荐）：对最终定式数据进行压缩，显著减少磁盘占用空间
- **仅保留最优分支**：剔除次优信息，精简数据体积，需投入额外计算时间
- **低成功率剪枝**（推荐）：计算完成后剔除低成功率局面，在不损失计算精度的前提下优化存储

**高级选项**：
- **高级算法**：启用高级算法，大幅优化超大定式的计算速度和内存占用（仅推荐用于大定式）
- **小数之和上限(STSL)**：控制高级算法的剪枝强度，成功率准确性和计算速度的权衡
- **分块回算**：通过分块 IO 大幅降低内存门槛，适合内存受限时计算超大定式，建议配合 SSD 使用。
- **成功率精度**：自定义成功率数据的存储精度和格式


点击 **BUILD（开始计算）** 按钮开始计算。计算过程中会显示实时进度，支持断点重连。

**关于断点重连的注意事项：**

程序虽支持断点续算，但若因磁盘满或异常崩溃导致中断，可能损坏最近写入的文件。直接重连可能导致后续计算错误。
安全操作建议：重连前检查最新生成的文件大小，手动删除最后 2-3 个异常文件或文件夹，以确保数据完整性。

### 4.2.2 全局设置部分

**颜色与主题**：
- **方块背景色**：选择数字块的颜色方案（2-32768 对应不同颜色）
- **颜色主题**：40+ 种预设主题（Classic、Royal、Supernova 等）
- **配色方案**：深色模式，重启生效。编辑 `color_schemes.txt` 文件进行深度定制

**游戏参数**：
- **出四率**（生成 4 的概率）：范围 0-1，默认 0.1（10%）
- **错题本阈值**：错题本将记录测试过程中单步吻合度低于此值的局面
- **字号**：调整界面字号大小，适应不同分辨率
- **动画**：关闭方块移动和合并的动画可减少卡顿

## 4.3 Game（游戏界面）

提供基础 2048 游戏功能，包括标准玩法和 AI 辅助。

### 4.3.1 游戏操作

**基本控制**：
- **移动**：方向键或 WASD
- **撤回**：撤销上一步操作（仅在 AI OFF 时可用）
- **重开**：开始新游戏
- **AI**：点击 **"AI: ON"** 按钮切换

### 4.3.2 难度设置

**难度滑块**：
- 位于游戏界面下方，向右拖动增加难度
- 数字生成由算法控制，倾向于在不利位置生成
- AI 基于随机生成逻辑计算，不建议在困难模式下使用 AI 辅助

## 4.4 MiniGame（小游戏界面）

提供多种改版 2048 游戏，玩法新颖、难度更高，适合寻求挑战的玩家。

| 游戏名称 | 棋盘大小 | 核心机制 | 难度 |
|--------|--------|---------|-----|
| **Blitzkrieg** | 4x4 | 倒计时（3分钟），时间内合成更高数字可获得时间奖励 | 中~高 |
| **Design Master 1-4** | 4x4 | 按指定图案排列方块；需要在特定位置合成目标数字以形成预设图案 | 中 |
| **Column Chaos** | 4x4 | 定时列交换；每操作40步后两列自动随机交换位置，需适应棋盘变化 | 中 |
| **Mystery Merge 1-2** | 4x4 | 隐藏方块；大部分方块显示为"?"，仅发生合并的位置才会显示；需要通过试错推断棋盘状态 | 高 |
| **Gravity Twist 1-2** | 4x4 | 自动重力；每操作后自动向某个方向移动一次 | 中 |
| **Ferris Wheel** | 4x4 | 定时旋转；每操作40步后外围12个方块顺时针旋转一格 | 中~高 |
| **Ice Age** | 4x4 | 冰冻机制；方块若不移动80+步，则冻结成不可移动的冰块，需要保持流动性 | 高 |
| **Isolated Island** | 4x4 | 孤立瓷砖；随机生成特殊瓷砖，只能与自己合并，不能与其他数字合并 | 中~高 |
| **Shape Shifter** | 可变 | 变形棋盘；棋盘形状从12x12的不规则形状随机生成，每局大小和形状不同 | 中~高 |
| **Tricky Tiles** | 4x4 | 对抗AI生成；新数字由对抗AI在较坏位置生成 | 高 |
| **Endless Factorization** | 4x4 | 因子分解；随机生成特殊方块，移动时对接触到的首个方块进行因数分解；可无尽 | 低 |
| **Endless Explosions** | 4x4 | 炸弹消除；随机生成炸弹，移动时消除接触到的首个方块；可无尽 | 低 |
| **Endless Giftbox** | 4x4 | 礼盒变形；随机生成礼盒，内容随机新数字；可无尽 | 中 |
| **Endless Hybrid** | 4x4 | 混合机制；随机生成多种特殊对象（炸弹/坑洞/礼盒），各有不同效果；可无尽 | 高 |
| **Endless AirRaid** | 4x4 | 空袭目标；随机位置出现目标标记，被标记的位置出现方块时被"空袭"消除；可无尽 | 中 |


**HardMode 按钮**：位于界面左下角。启用后增加游戏难度的方式因游戏而异。


## 4.5 Practice（练习界面）

展示定式数据和最优走法，是学习和研究的核心工具。

### 4.5.1 界面布局

**控制面板**：
- 菜单栏选择要查看的定式
- 选择定式文件所在路径
- 显示/隐藏当前局面四个方向的成功率
- 点击右下角数字按钮编辑局面

**棋盘区域**：
- 显示当前局面
- 显示局面编码


### 4.5.2 功能按钮

**局面操作**：
- **设置盘面**：将输入框中的编码加载为棋盘局面
- **初始局面**：显示该定式的随机初始局面
- **翻转棋盘**：进行翻转、旋转操作

**演示功能**：
- **自动推演**：连续自动执行最优走法，展示完整的求解过程
- **步进**：单步执行一次最优走法，方便逐步学习
- **撤回**：撤销上一步操作

**局面编辑**：
  - **彩色数字按钮**（0-32k）：点击进入"摆盘模式"
  - **左键**：摆盘模式下，左键盘面将对应位置设为已选中的数字
  - **右键**：摆盘模式下，右键盘面将对应位置增大一级（2→4→8...）
  - **其他键**：摆盘模式下将对应位置减小一级
  - 点击已选中的按钮退出摆盘模式

**录像功能**：
- **录制**：录制自动推演演示的走法序列和成功率数据
- **加载录像**：从文件加载以前保存的演示
- **播放录像**：播放已加载的演示内容

**手动模式**：
- 棋盘停止自动生成新数字
- 左键点击空位：放置 2
- 右键点击空位：放置 4

### 4.5.3 快捷键

- **方向键 / WASD**：移动操作。
- **Enter (回车)**：若正在自动推演则停止演示；若焦点在编码框则加载局面编码；其他情况执行单步最优走法。
- **Backspace / Delete**：撤回上一步操作 (Undo)。
- **Q**：切换手动模式。
- **Z**：截图当前棋盘并复制到剪贴板。
- **E**：视为点击了数字按钮 0。

## 4.6 Test（测试界面）

测试界面用于评估玩家的残局技能水平，提供实时反馈和成绩分析。

### 4.6.1 基本测试流程

**1. 选择定式**：
- 从上方菜单栏选择要测试的定式
- 若定式数据未加载，需进入练习界面指定路径

**2. 选择初始局面**：
- 系统随机生成初始局面
- 可在练习界面手动设置局面，复制编码后粘贴到此处

**3. 执行操作**：
- 使用 **↑↓←→** 或 **WASD** 进行操作
- 每次移动后系统自动生成新数字

**4. 查看反馈**：
- 实时显示最优走法和当前走法的吻合度
- 显示累积吻合度和当前连击数
- 对局自动记录到"错题本"

### 4.6.2 高级功能

**Verse 回放分析**：
- 点击 **"分析 Verse 回放"** 按钮
- 导入来自 *2048verse.com* 的游戏回放文件（`.txt` 格式）
- 自动从全量回放中提取定式相关的残局片段并评分
- 为每个片段生成详细的分析报告和回放文件

**回放复盘**：
- 点击 **"回放复盘"** 按钮
- 支持复盘当前测试对局或 *Verse* 回放分析生成的 `.rpl` 文件
- 支持快进、快退、精准定位“漏着”
- 逐步拆解历史对局

**错题本功能**：
- 位于测试界面下方
- 自动记录低吻合度局面
- 可按定式、重要性等条件筛选
- 可跳转练习界面查看当前局面的走法

### 4.6.3 快捷键

- **方向键 / WASD**：移动操作，实时触发定式比对。
- **R**：快速重置，并保存`.rpl`回放至默认目录。
- **F**：显示/隐藏右侧实时分析文本。

---

# 5、快速入门

定式计算是使用 AI 模块、练习模块、测试模块等重要功能的前提，您需要先计算并保存一个**定式**。

## 5.1 计算定式（Settings 界面）

按以下步骤计算第一个定式：

1. 进入主菜单，进入设置界面
2. 定式名称选择 `L3` 或 `442`，目标数字选择 `256`
3. 指定保存路径（例如 `F:/L3_256`）
4. 勾选 **compress**，其他选项保持默认
5. 点击 **BUILD** 按钮开始计算

## 5.2 学习定式（Practice 界面）

计算完成后，进入 **Practice** 界面学习该定式的最优走法：

1. 进入主菜单，进入练习界面
2. 在左上角菜单栏选择刚计算的定式
3. 若计算已完成，程序自动显示保存路径和随机初始局面
4. 显示四个方向的成功率
5. 点击**初始局面**按钮切换随机初始局面
6. 连续演示最优走法，观察如何从初始局面进行到目标数字

## 5.3 掌握定式（Test 界面）

通过测试验证对定式的掌握程度：

1. 进入主菜单，进入测试界面
2. 在左上角菜单栏选择要测试的定式
3. 输入自定义局面编码（或系统随机生成）
4. 执行您认为最佳的走法
5. 观察右侧实时分析面板

---

# 6、定式计算算法

## 6.1 基础设计

### 6.1.1 局面位表示 (Bitboard Representation)

软件采用一个 **64位无符号整数 (uint64)** 来表示 4x4 的棋盘状态。棋盘共 16 个格子，每个格子占用 4 Bits，总计 64 位。

### 6.1.2 查找表与移动函数 (LUT & Move Function)

为了避开合并逻辑中的循环和分支，采用基于 **查找表 (LUT)** 的加速方案。

 1. 在初始化阶段预先计算所有可能的 16 位行状态（共65536种组合）
 2. 查找表不直接存移动结果，而是存储 **“移动后状态”与“原始状态”的异或 (XOR) 值**。
 3. 通过旋转变换，将向上/向下的移动逻辑转化为对行的操作。
 4. 提取局面中的行/列，查表获取对应的异或差值，将其应用回原局面。

### 6.1.3 对称性与规范化 (Symmetry & Canonical Forms)

在定式计算中，许多局面通过翻转或旋转后在逻辑上是完全等价的。为了减少冗余计算，引入了 **规范化 (Canonical)** 机制。

实现了以下对称变换：
* **镜像翻转**：水平翻转 (`ReverseLR`)、垂直翻转 (`ReverseUD`)。
* **旋转变换**：顺时针/逆时针 90 度旋转 (`RotateL/RotateR`)、180 度旋转 (`Rotate180`)。
* **对角翻转**：主对角线翻转 (`ReverseUL`)、副对角线翻转 (`ReverseUR`)。


在存储局面之前，程序将局面及其对称形态进行对比，并选择 **数值最小** 的形态进行存储。针对特定定式，可选择仅进行对角线规范化或水平规范化。

## 6.2 生成与求解逻辑

定式算法的核心可以概括为：**前向分层搜索生成（BFS）**与**后向动态规划回算（DP）**。通过将庞大的局面空间拆分为不同的“层（Layer）”，程序能够在有限的资源下完成超大规模定式的计算。

### 6.2.1 前向局面生成 (Forward BFS)

程序首先从一个或多个初始局面（Seed Boards）开始，采用广度优先搜索算法探索所有可能的局面空间，称为生成阶段（generating）。

#### 1. 分层搜索逻辑
为了优化内存效率，局面被划分为不同的“层”。划分依据通常是棋盘上所有数字的对数和。
- **状态迁移**：每一层的局面通过“填充新数字”和“执行移动”两个动作，推导出下一层可能出现的局面。
- **操作循环**：对于层中的每一个局面，程序会遍历所有空位，分别尝试填入数字 2 和 4，随后执行四个方向的移动。如果移动后的局面符合定式范围（Pattern Check）且局面发生了变化，则将其记录。

#### 2. 排序和去重
- **预去重**：在生成过程中，使用哈希表（Hash Map）进行即时缓存/过滤，减少内存开销。该过程不处理哈希碰撞，只起到降低重复率的作用。
- **排序去重**：每一层生成结束后，对数据进行排序并删除重复项。排序的目的一是去重需要，二是储存有序的局面方便查找。

#### 3. 内存管理与预测
- **长度预测**：程序会预测下一层局面的增长规模，动态预分配内存空间。
- **分段处理（Segmentation）**：当单层规模超过系统可用内存阈值时，程序会自动将数据切分为多个片段（Segments），逐个处理并归并。

### 6.2.2 后向成功率回算 (Backward recalculation)

当所有层级的局面生成完毕并持久化到磁盘后，程序转入求解阶段（solving）。

#### 1. 边界条件
- 如果局面中特定位置出现了目标数字，该局面被标记为 100% 成功。
- 如果一个局面无法再进行任何有效移动，则其成功率为 0%。

#### 2. 成功率计算
对于每一个局面 $B$，其成功率 $P(B)$ 取决于其所有可能移动方向中，能获得的最大成功率期望值：

$$P(B) = \max_{d \in \{U, D, L, R\}} \left( 0.9 \times \sum_{s_2 \in S_2(d)} \frac{P(s_2)}{N_{empty}} + 0.1 \times \sum_{s_4 \in S_4(d)} \frac{P(s_4)}{N_{empty}} \right)$$

其中：
- $d$ 代表移动方向。
- $S_2(d)$ 和 $S_4(d)$ 分别是在该方向移动后，填入数字 2 和数字 4 所产生的后续局面集合。
- $N_{empty}$ 是移动后棋盘上的空位总数。

#### 3. 索引与查找机制

- **前缀索引 (Prefix Indexing)**：建立索引表，提取 uint64 数据的前 24 位（header）作为索引键，记录每个 24 位前缀在排序数组中首次出现的偏移量（offset）。
    
- **查找流程 (Search Strategy)**：1.计算目标局面的 header 2.从 表中获取二分查找范围 3. 在窄范围内执行二分查找。


### 6.2.3 断点续传与容错控制

鉴于超大定式的计算可能持续数小时乃至数天，程序内置了完善的容错机制：
- **层级持久化**：每层计算完成后，数据立即写入磁盘。
- **断点重连**：程序启动时自动检测已生成文件。计算中断后重新启动，程序从最后一个完整层级恢复，避免重复计算。


## 6.3 高级算法 (Advanced Algorithm)

高级算法是本程序的关键技术突破，专为处理 `free10`、`4442ff` 及更高级别的超大型定式而设计。在这些定式中，单层局面总数可达 10^10 至 10^11 量级（如 `free12`），常规算法因内存和复杂度限制，几乎无法在个人电脑上完成计算。

### 6.3.1 设计理念：大数掩码与等价类划分

高级算法通过"掩码化（Masking）"技术，将棋盘数字分为两类进行差异化处理：
- **大数**：数值在 [64, 32768] 范围的数字。
- **小数**：数值 ≤32 的数字。

#### 1. 局面掩码化 (Masking)
在生成阶段，算法将暂时不涉及合并操作的大数统一视为一个特殊的占位符（Mask）。
- **等价类**：一个带掩码的局面（masked board）可"代表"数千个仅大数排列方式不同、局部逻辑一致的局面。
- **状态压缩**：通过仅生成带掩码局面，广度优先搜索的状态空间被压缩 10-100 倍以上，显著减轻排序去重和二分查找的压力。

#### 2. 动态拆分与还原 (Unmasking/Derive)
当棋盘新生成数字可能导致大数合并时（例：盘面已有128，又合出一个128），算法执行"暴露（Derive）"操作，将原有大数（例：128）还原为具体数值。
- **全位置暴露策略**：掩码局面中通常存在多个大数占位符。因掩码局面代表一类局面集合，我们无法预知特定数值的具体位置。为穷举所有可能性，算法生成该数值在所有可能位置上的局面，派生出具体局面集合。
- **计算开销分析**：暴露后的局面多数为游戏流程中可达状态（Reachable），故还原仅增加极少无效计算。

---

### 6.3.2 启发式剪枝规则

为了充分利用算法优势，高级算法引入了启发式剪枝逻辑：

#### 1. 大数组合限制
算法对同时存在的大数种类和数量进行限制：
- 最小大数外的其余大数，至多各存在一个
- 最小大数 > 64 时，其最多同时存在 2 个
- 最小大数 = 64 且盘面无 128 时，其最多同时存 3 个
- 合法：`(4k, 2k, 512, 128, 128)`、`(512, 64, 64, 64)`
- 非法：`(4k, 2k, 512, 128, 128, 128)` 或 `(4k, 2k, 512, 128, 128, 64)`

#### 2. 小数之和上限 (STSL)
通过超参数 **SmallTileSumLimit (STSL)** 精确控制小数复杂度：
- 所有小数之和 ≤ STSL + 64
- 局面存在两个相同大数时，小数和 ≤ STSL
- 存在三个64时，小数和 ≤ STSL - 64
- 单步限制：每步移动至多合出一个新大数

实际上，只需每32个layer进行一次小数之和剪枝即可。

### 6.3.3 批量回算机制 (Batch Solving)

高级算法回算的核心在于将“掩码局面”视为一个向量进行整体演化，利用变换编码解决顺序一致性问题。

#### 1. 全面还原 (Full Unmasking) 与基数：
   - **全面还原**：根据大数组合将所有掩码位完全暴露。
   - **有序性**：全面还原得到一组严格升序的局面。
   - **Unmasked 基数**：还原后的局面总数，由大数组合决定。
   - **数据结构**：每个掩码局面关联一个成功率数组 (Success Rate Array)，数组长度等于Unmasked基数，与局面序列一一对应。
   - **注意**：全面还原过程较为耗时，故算法核心在于利用掩码机制减少全面还原。

#### 2. 变换编码与缓存表：
   - 问题：掩码局面在“移动+规范化”这组变换后，其对应的局面序列有序性会被破坏。（设局面为 B，全面还原操作为 U，变换（移动&规范化）为 T。T(U(B)) 的结果集合虽然与 U(T(B)) 相同，但其内部局面的序列顺序（Index Order）会发生重排）
   - 这导致查询得到的成功率数组与当前棋盘状态失配，无法进行期望值计算。
   - 标签化与示踪：引入变换编码。变换前，遍历掩码局面中所有的掩码位（`0xf`），并按顺序赋予递减的“标签”（`0xf, 0xe, 0xd...`）。变换后，观察这些“标签”最终落在了哪些位置，并将其排列状态压缩为一个唯一的特征值 `ind`。
   - 规律：`ind` 相同的掩码局面，其局面序列的受扰动的模式完全一致。
   - 映射修复：利用特征值 `ind` 检索缓存表中的 ranked_array。该数组记录了从“扰动序列”回溯至“原始升序序列”的索引映射。
   - 效果：通过 Success Rate Array[ranked_array] 实现对成功率数组的 O(n) 对齐，避免在回算循环中反复执行全面还原与索引排序。

#### 3. 动态分类处理：
   - 基数变化：生成新大数后，Unmasked 基数发生变化。需要重新当前评估大数组合，对查询到的成功率数组进行筛选或多次查询合并。
   - 基数等于 1：回退到常规算法的逻辑。

#### 4. 优势总结：
   - 通过批量回算极大地减少了二分查找的次数。
   - 对成功率数组的整体处理，并行化程度高。
   - 可根据大数组合分块，支持在大规模计算时通过分块回算进一步压低内存峰值。


### 6.3.4 算法优势

与常规算法相比，高级算法处理超大定式具有压倒性优势：

| 维度 | 常规算法 (General) | 高级算法 (Advanced) |
| :--- | :--- | :--- |
| **计算用时** | 随定式增大超线性减慢 | 定式越大，提速越明显（可达 10x 以上） |
| **内存占用** | 至少需 2 倍单层局面内存 | 峰值内存占用降低 1 个数量级 |
| **并行效率** | 容易并行 | 并行化程度更高 |
| **存储效率** | 文件较大，需额外压缩 | 中间文件精简，最终定式文件更小 |

借助该算法，目前已在9950x 128GB内存的计算机上成功计算`free12-4096`，总耗时约24天。

### 6.3.5 使用限制与注意事项

- **适用范围**：专门为计算 `free10`、`free12`、`4442ff` 等超大定式设计。对于 `L3`、`t` 等极小的定式，高级算法反而可能导致性能下降。
- **精度损耗**：由于存在剪枝，成功率的计算结果会有微小偏差。几乎不影响最优操作路径的选择。
- **功能冲突**：不支持仅保留最优分支选项，不支持变体定式，不适用含't'后缀的定式（以及其他存在可移动但移动受限的大数的定式）。
- **压缩特性**：常规算法压缩率高。其主要原理是局面数据存在大量冗余，压缩算法能极大地减小局面存储体积。高级算法压缩率相对较低。这是因为掩码机制下，高级算法储存的数据中大部分是成功率数据。高精度的成功率数据表现出极高的信息熵，接近随机数序列，传统的无损压缩算法对此类数据的压缩空间非常有限。

---

# 7、关于AI

## 7.1 AI性能
目前最强的AI
-  不可撤销的情况下测试1200局，**65536 成功率 8.4% (±1.6%)，32768 成功率 86.1% (±2.0%)**。
   
     | search depth    | games | avg score  | median score | moves/s |
     |-----------------|-------|------------|--------------|---------|
     | 1~9 adaptive    | 1200  | 772353     | 819808       | 11      |

- 分段成功率

     | milestone     | success rate | comparable score |
     |---------------|--------------|------------------|
     | 8k            | 100%         | 97000            |
     | 16k           | 99.9%        | 210000           |
     | 32k           | 86.1%        | 453000           |
     | 32k+16k       | 72.8%        | 663000           |
     | 32k+16k+8k    | 61.8%        | 760000           |
     | 32k+16k+8k+4k | 53.3%        | 804000           |
     | final 2k      | 46.3%        | 824000           |
     | 65k           | 8.4%         | 971000           |


![survival rate](https://github.com/user-attachments/assets/8d708f06-4994-4878-8e27-2aa831db1a2b)



-  定式使用情况

     | Search | free12-2k     | free11-2k | 4442f-2k | free11-512  |
     |--------|----------------|------------|----------|--------------|
     | 26.49% | 13.38%         | 1.41%      | 51.50%   | 7.22%        |


## 7.2 AI测试
需要一定的编程知识。单独运行AItest.py，其中run_test函数将单次测试的游戏记录写入指定路径。

## 7.3 通用AI
AI能够使用任意已计算的定式。
但其目前不会根据可用定式组合调整自身策略，因此难以单独利用`t`、`444`等定式。
根据定式大小从小到大，推荐计算`L3\LL\4431\4432f\free10\4442ff\free11\4442f\free12`。计算的定式越多、越大，AI性能越强。

## 7.4 AI 引擎与调度系统

残局是2048最困难的阶段。本AI在游戏前期依靠搜索决策；在进入特定残局阶段时，切换至定式调度系统，利用预计算的全局最优解确保残局成功率

### 7.4.1 Expectimax 搜索

- 搜索深度随空位数量动态调整，范围通常在 2-5 层。
- 评估维度：通过行/列查找表评估数字排列的合理性。
- 缓存机制：内置基于哈希的缓存表，减少重复计算。

### 7.4.2 定式调度器 (Dispatcher)

调度器的逻辑是：识别当前残局状态 -> 匹配对应定式 -> 提取最优解

定式优先级：定式按“大数数量 + 目标对数”进行分类。优先选择残局级别匹配、约束更少的定式（`free`）。若所有定式均无法提供有效成功率，自动回退到搜索模式。

---

# 8、常见问题解答

# 8、常见问题解答 (FAQ)

### Q1: 为什么软件启动或切换功能时需要较长时间？
**A1**: 软件基于 **Numba JIT (即时编译)** 优化计算模块。首次调用时代码被编译为 CPU 优化的机器码，导致 2-10 秒的初始化延迟，属于正常现象。


### Q2: 升级版本时，如何迁移设置和错题记录？
**A2**: 保留配置和错题本的步骤：
1. 旧版根目录复制 `mistakes_book.pkl` 和 `_internal` 下的 `config` 文件。
2. 粘贴并覆盖到新版本对应路径。
3. 其余配置文件同理。


### Q4: 计算过程中内存占用极高？
**A4**: 解决方案：
1. **分段处理**：程序内置分段算法，但内存极小时仍会受限。
2. **设置虚拟内存**：将 SSD 虚拟内存设为 64GB 或更高。
3. **启用分块回算**：高级算法回算阶段勾选，用磁盘 I/O 换取内存。


### Q5: 计算意外中断后如何安全断点继传？
**A5**: 意外中断可能损坏文件。恢复步骤：
1. **安全回退**：检查输出文件夹最后修改 2-3 个文件。若体积异常（0KB 或远小于前序文件），手动删除。
2. **恢复计算**：重新打开程序，保持参数不变，点击 **BUILD**，程序自动从最后完整层级恢复。
3. **检查日志**：反复报错时查阅根目录 `logger.txt` 定位问题。


### Q6: 计算卡死（CPU 占用低，计算无进展，磁盘 IO 挂起）？
**A6**: 常见于使用外置移动硬盘时，硬盘进入休眠或响应延迟。
1. **手动唤醒**：尝试向该硬盘手动拷贝一个文件，强制系统激活磁盘写入。
2. **硬件优化**：建议关闭外置硬盘的节能模式，或将定式计算路径设在本地 SSD 上。


### Q7: 计算了定式，AI 表现仍不及预期？
**A7**: 排查步骤：
1. **路径验证**：**Practice** 界面切换定式名，确认路径显示正确文件夹。
2. **调度逻辑**：盘面数字和极小时调度器切换到 AI 搜索。等待局面演化至定式要求的阵型。


### Q8: 界面文字显示不全或棋盘方块变形？
**A8**: UI 适配了不同分辨率，但受系统缩放比例（DPI）影响：
1. **手动调节**：调整“字号”参数。
2. **系统设置**：右键 `main.exe` > 属性 > 兼容性 > 更改高 DPI 设置 > 由应用程序执行缩放。


# 9、支持和反馈

## 9.1 获取支持

如果在使用软件过程中遇到任何问题，您可以通过以下方式获得技术支持：

**GitHub 提交 Issue**  

   - 如果遇到软件中的问题或错误，您可以访问[GitHub 项目页面](https://github.com/game-difficulty/2048EndgameTablebase)并提交 Issue。请详细描述您遇到的问题，提供任何可能帮助我们复现问题的信息（如定式名称、错误日志、操作步骤等）。

**加入社区**  

   - 加入2048在线社区，与其他用户互动，分享经验，讨论问题和解决方案。
   - **QQ群**：94064339  
   - **Discord 频道**：2048 Runs

## 9.2 提交反馈

**在 GitHub 上为项目添加星标**  

   - 如果您喜欢这个项目，或者觉得它对您有帮助，欢迎在[GitHub 项目页面](https://github.com/game-difficulty/2048EndgameTablebase)上为我们的项目点一个星标（Star）。

---


# 10、附录

## 10.1 定式大小参考

| Formation    | ~Size  | ~Compressed |
|--------------|--------|-------------|
| LL_4096_0    | 1.1 TB | 450 GB      |
| 4431_2048    | 650 GB | 250 GB      |
| 444_2048     | 130 GB | 60 GB       |
| t_512        | 2.5 GB | 1 GB        |
| L3_512_0     | 2 GB   | 1 GB        |
| 442_512      | 2 GB   | 1 GB        |
| 4432_512     | 250 GB | 100 GB      |
| 4441_512     | 800 GB | 330 GB      |
| 4432f_2048   | 3.5 TB | 1.33 TB     |
| free8_128    | 3.5 GB | 1 GB        |
| free10_1024  | 2 TB   | 700 GB      |

表中为常规算法下，使用32位精度，不删除低成功率局面的定式大小。一般规律是：相同残局级别，空位每多一格，体积增大1个数量级；相同空位数，free定式比大数移动受限的定式大3个数量级；体积随目标数字翻倍而翻倍；相同残局级别，相同空位数，大数移动受限的定式大小受可用对称性的影响较大。

设置较高的删除阈值可极大地减少最终体积，但不应过高。推荐的阈值上限：16k残局 ~80%, 32k残局 ~40%, 65k残局 ~5%。

## 10.2 黑科技

以下技巧需对定式算法有深入理解的玩家操作。

1. **压缩解耦**
计算时，不勾选压缩选项以加快生成和回算速度。计算完成后保持参数不变，重新勾选压缩并再次计算。程序将识别已有定式并执行增量压缩。

2. **空间腾挪**
超大定式计算时，SSD 容量不足可进行"冷热分离"：
- **热数据**：当前计算的 Layer 及相邻 20-30 个文件保留在 SSD 确保 I/O 性能。
- **冷数据**：已完成或短期不用的文件移至 HDD。
- **虚拟路径**：程序断点检查仅验证文件名存在性，不校验内容。可在 SSD 原路径下创建空文件"欺骗"断点续传。
- **多路径加载**：计算完后定式分布于多驱动器内，无需合并，在练习界面分别输入各磁盘路径即可跨盘识别。

3. **自定义定式**
修改 patterns_config.json 自定义定式参数：
   - **valid pattern**：移动受限大数的合法空间掩码。
   - **target pos**：目标数字的合法产出位置。
   - **canonical mode**：对称规则与规范化函数。
   - **seed boards**：起始局面编码，要求数字和相同。
   - **extra steps**：额外步数。总步数 = 目标数字/2 + extra steps（可为负，但需确保步数内可合并出目标数字）。

修改后重启软件，在菜单加载并计算自定义定式。


